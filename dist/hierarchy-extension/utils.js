"use strict";!function(){const e={LogLevel:{DEBUG:0,INFO:1,WARN:2,ERROR:3},log(e,t,...o){if(e<this.LogLevel.WARN)return;const n=`[${(new Date).toISOString().split("T")[1].split(".")[0]}][${Object.keys(this.LogLevel)[e]}][${t}]`;switch(e){case this.LogLevel.WARN:console.warn(n,...o);break;case this.LogLevel.ERROR:console.error(n,...o)}},debounce(e,t){let o=null;return function(...n){o&&clearTimeout(o),o=window.setTimeout((()=>{e.apply(this,n),o=null}),t)}},throttle(e,t){let o=0;return function(...n){const r=Date.now();r-o>=t&&(e.apply(this,n),o=r)}},safeQuerySelector(e,t=document){try{return t.querySelector(e)}catch(t){return this.log(this.LogLevel.ERROR,"DOM",`选择器错误: ${e}`,t),null}},appendChildren(e,t){const o=document.createDocumentFragment();t.forEach((e=>o.appendChild(e))),e.appendChild(o)},waitForCondition:(e,t=1e4,o=100)=>new Promise(((n,r)=>{const i=Date.now(),s=()=>{e()?n():Date.now()-i>=t?r(new Error("等待条件超时")):setTimeout(s,o)};s()})),async exponentialRetry(e,t=5,o=100){let n=0;for(;;)try{return await e()}catch(e){if(n>=t)throw e;const r=o*Math.pow(2,n);this.log(this.LogLevel.WARN,"Retry",`重试 ${n+1}/${t}，延迟 ${r}ms`),await new Promise((e=>setTimeout(e,r))),n++}}};window.utils=e}();
